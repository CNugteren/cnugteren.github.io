---
layout: default
title: Cedric Nugteren | Projects
current: 3
---

<br/>
<br/>
Below you'll find a short summary of my open-source hobby projects.
<br/>
<br/>

{% include project.html
	shortname = "NLWeer"
	longname = "A free, open-source, and privacy-friendly Dutch weather prediction app"
	language = "Android, Kotlin"
	dates = "10/2019 - today"
	description = "NLWeer is a simple open-source and privacy-friendly Dutch weather app for Android (5.0 or newer). It is free both as in free lunch and as in freedom. Weather information is provided by KNMI or optionally by Buienradar, see the about screen in the app for more information."
	image = "nlweer.png"
	github = "CNugteren/NLWeer"
variable-param=page.variable %}


{% include project.html
	shortname = "Midisurf"
	longname = "An Audiosurf/guitar-hero like game for the Atari ST"
	language = "Atari ST, C89, TOS"
	dates = "08/2019 - 10/2019"
	description = "
Midisurf is an Audiosurf/GuitarHero-like game based on Midi files. It is created in 2019 for the 1985 Atari ST computer, and is written in C. At the start of the game, a Midi file from disk has to be selected. This Midi file is being played on the Atari ST YT sound-chip, while the player(s) of the game have to press keys on the keyboard at the right time to 'play along' the Midi track.<br/><br/>
Below you'll find an Atari ST emulator with the game loaded in the A: floppy drive. Unfortunately, <b>audio does not work</b> (exactly what the game is about!), so to really see what it looks like, you'll have <a href=https://github.com/CNugteren/midisurf#running-midisurf-on-an-emulator>install it in a proper emulator</a>.
<br/>

<div class='pcejs pcejs-container'>
  <div class='pcejs pcejs-loading-status'>Loading...</div>
  <div class='pcejs'>
    <canvas class='pcejs pcejs-canvas' oncontextmenu='event.preventDefault()'></canvas>
  </div>
</div>
<script type='text/javascript' src='atari/bundle.js'></script> 

<br/>
The above Javascript app runs the <a href=https://github.com/jsdf/pce>pce-js Atari ST emulator</a>. If the mouse doesn't position correctly, go to one of the corners you can reach, move out and then slowly move into the emulator's screen to match the two cursors.
"
	image = "atarist.jpg"
	github = "CNugteren/Midisurf"
variable-param=page.variable %}


{% include project.html
	shortname = "PyPopQuiz"
	longname = "A Python/ffmpeg-based popquiz creator"
	language = "Python, FFMPEG"
	dates = "08/2018 - 10/2019"
	description = "PyPopQuiz is a python package to generate popquiz-videos (questions and answers) based simple JSON files with descriptions of the quiz-questions. Such a JSON description could for example contain a song's title and answer which need to be guessed, along with a YouTube-link and two time-intervals defined for the audio and/or video question and answer. It includes features such as only audio, only video, combined audio and video, local files, YouTube links, reversed audio, text overlays, missing words rounds, and so on."
	image = "popquiz.jpg"
	github = "CNugteren/PyPopQuiz"
variable-param=page.variable %}


{% include project.html
	shortname = "CLBlast"
	longname = "The tuned OpenCL BLAS library"
	language = "C++11, OpenCL"
	dates = "05/2015 - today"
	description = "CLBlast is a modern, lightweight, performant and tunable OpenCL BLAS library written in C++11. It is designed to leverage the full performance potential of a wide variety of OpenCL devices from different vendors, including desktop and laptop GPUs, embedded GPUs, and other accelerators. CLBlast implements BLAS routines: basic linear algebra subprograms operating on vectors and matrices.
	<br/><br/>
	More information on the <a href=/clblast/clblast.html>project page of CLBlast</a>."
	image = "clblast.png"
	github = "CNugteren/CLBlast"
variable-param=page.variable %}


{% include project.html
	shortname = "CLCudaAPI"
	longname = "A portable CUDA/OpenCL high-level API"
	language = "C++11, OpenCL, CUDA"
	dates = "08/2015 - 10/2017"
	description = "CLCudaAPI provides a C++ interface to the OpenCL API and/or CUDA API. This interface is high-level: all the details of setting up an OpenCL platform and device are handled automatically, as well as for example OpenCL and CUDA memory management. A similar high-level API is also provided by Khronos's cl.hpp, so why would someone use CLCudaAPI instead? The main reason is portability: CLCudaAPI provides two header files which both implement the exact same API, but with a different back-end. This allows porting between OpenCL and CUDA by simply changing the header file!"
	image = "clcudaapi.jpg"
	github = "CNugteren/CLCudaAPI"
variable-param=page.variable %}


{% include project.html
	shortname = "CLTune"
	longname = "Automatic OpenCL kernel tuning"
	language = "C++11, OpenCL"
	dates = "01/2015 - 06/2017"
	description = "CLTune is a C++ library which can be used to automatically tune your OpenCL kernels. The only thing you'll need to provide is a tuneable kernel and a list of allowed parameters and values.
	<br/><br/>
	For example, if you would perform loop unrolling or local memory tiling through a pre-processor define, just remove the define from your kernel code, pass the kernel to CLTune and tell it what the name of your parameter(s) are and what values you want to try. CLTune will take care of the rest: it will iterate over all possible permutations, test them, and report the best combination."
	image = "cltune.png"
	github = "CNugteren/CLTune"
variable-param=page.variable %}